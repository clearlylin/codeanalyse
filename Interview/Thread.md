# Thread

## 线程锁

1、自旋锁，不会引起CPU调度，通过忙等待的方式不断查询锁是否获取，busy_waiting，
2、互斥锁，保证只存在一个线程访问，信号量为1，sleep_waiting
3、读写锁，保证只存在一个线程进行写操作，允许多个线程进行读操作,
4、条件锁，
5、写时拷贝，使用读多写少的场景，并且属于数据最终一致性的方案
经典例子：
在linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制”技术，也就是只有进程空间的各段的内容要发生变化时，才将父进程的内容复制一份给子进程。
6、信号量，

## 线程安全

多个线程访问或者调用同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，对象就是线程安全的

线程安全问题都是对全局变量或静态变量进行写操作引起的，多个线程能同时写造成覆盖引起的结果不一致

实现线程安全的两种方式：
(1)避免竞争
可重入的结构与原子操作，线程本地存储，不可变对象
(2)锁同步

## 可重入性

可重入：多个执行流反复执行一个代码，其结果不会发生改变，通常访问的都是各自的私有栈资源
可重入函数：函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时继续执行不会影响函数的执行结果
可重入函数可以在任意时刻被中断，稍后再继续运行，不会丢失数据。
可重入函数满足条件
(1)不使用全局变量或静态变量；
(2)不使用用malloc或者new开辟出的空间；
(3)不调用不可重入函数；
(4)不返回静态或全局数据，所有数据都有函数的调用者提供；
(5)使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据；

满足下列条件的函数多数是不可重入的：
1) 使用了静态的数据结构；
2) 调用了malloc()或者free()函数；
3) 调用了标准I/O函数。
4) 调用不可重入函数

线程安全也不一定是可重入

```C++
_Thread_local int tmp;
void swap(int* x, int* y)
{
    tmp = *x;
    *x = *y;
    *y = tmp;    /* Hardware interrupt might invoke isr() here. */
}
```

可重入函数不一定是线程安全

```C++
int tmp;
void swap(int* x, int* y)
{
    /* Save global variable. */
    int s;
    s = tmp;

    tmp = *x;
    *x = *y;
    *y = tmp;     /* Hardware interrupt might invoke isr() here. */

    /* Restore global variable. */
    tmp = s;
}
```

## 线程局部存储

线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。
这种对象的链接性（linkage）可以是静态的也可是外部的。
TLS的一个例子是用全局变量errno表示错误号。这可能在多线程并发时产生同步错误。线程局部存储的errno是个解决办法